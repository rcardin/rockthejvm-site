---
author: riccardo-cardin
category: guide
title: "Revisiting Design Patterns: The Builder Pattern"
excerpt: ""
publishedDate: 2025-02-10
tags: [design, design-patterns]
---

## Introduction

It's been 30 years since the Gang of Four published their seminal book on design patterns, called "Design Patterns: Elements of Reusable Object-Oriented Software". In the last three decades, the software industry has evolved significantly, and so have the best practices and patterns that we use to build software. Are the design patterns from the 90s still relevant today? Many software engineers would argue that they are not. In this series of articles, we will revisit some of the most popular design patterns and see how they evolved over time and which is the real legacy they left us. Since we have to start somewhere, let's start with the Builder Pattern.

## The Problem

In the book "[Design Patterns: Elements of Reusable Object-Oriented Software](https://books.google.it/books/about/Design_Patterns.html?id=6oHuKQe3TjQC&redir_esc=y)", each pattern describes a problem that occurs over and over again in our environment, and then describes the core of the solution to that problem, in such a way that you can use this solution a million times over, without ever doing it the same way twice. So, before we dive into the Builder Pattern, let's first understand the problem it tries to solve.

Imagine you have a complex object that you need to create. This object has many properties, some of which are mandatory, and some are optional. We could even have different flavors of the same object, with diffeerent properties. Let's make a concrete example.

Imagine we have to model a travel solution. A `Travel` is a very complex object, with many properties and constraint. Let's use the Java language to model it for now:

```java
public record Travel(
    String origin,
    String destination,
    LocalDate departureDate,
    LocalDate returnDate,
    int numberOfPassengers,
    List<Passenger> adults,
    List<Passenger> children
) {}

public record Passenger(
    String name,
    LocalDate birthDate,
    String passportNumber
    List<Ancillary> ancillaries
) {}

public record Ancillary(
    String name,
    Cost cost
) {}

public record Cost(
    BigDecimal amount,
    Currency currency
) {}

public enum Currency {
    USD,
    EUR,
    GBP
}
```

Even in this simple example, we can see that creating a `Travel` object is not trivial. We have many properties, some of which are mandatory, and some are optional. For example, a travel can be one-way or round-trip, and we have to specify the number of passengers, the list of adults, the list of children, and the list of ancillaries. The `Passenger` and `Ancillary` objects are also complex objects, with their own properties.

One-way flights don't have a `returnDate`, for example, so we could create a new constructor reflecting this fact:

```java
public record Travel(
    String origin,
    String destination,
    LocalDate departureDate,
    LocalDate returnDate,
    int numberOfPassengers,
    List<Passenger> adults,
    List<Passenger> children) {

    // Constructor for one-way flights
    public Travel(
        String origin,
        String destination,
        LocalDate departureDate,
        int numberOfPassengers,
        List<Passenger> adults,
        List<Passenger> children) {

        this(origin, destination, departureDate, null, numberOfPassengers, adults, children);
    }
}
```

As you see the constructor for the one-way flight is just a copy of the original constructor with the `returnDate` parameter set to `null`. We can reiterate the reasoning and create a new constructor for the round-trip flights that has only adults as passengers:

```java
public record Travel(
    String origin,
    String destination,
    LocalDate departureDate,
    LocalDate returnDate,
    int numberOfPassengers,
    List<Passenger> adults,
    List<Passenger> children) {

    // Constructor for one-way flights
    public Travel(
        String origin,
        String destination,
        LocalDate departureDate,
        int numberOfPassengers,
        List<Passenger> adults,
        List<Passenger> children) {

        this(origin, destination, departureDate, null, numberOfPassengers, adults, children);
    }

    // Constructor for round-trip flights with only adults
    public Travel(
        String origin,
        String destination,
        LocalDate departureDate,
        LocalDate returnDate,
        int numberOfPassengers,
        List<Passenger> adults) {

        this(origin, destination, departureDate, returnDate, numberOfPassengers, adults, List.of());
    }
}
```

We can stop here, but we can see that the number of constructors will grow exponentially with the number of optional properties. The one problem we have here is called constructor telescoping. The constructor telescoping anti-pattern occurs when a class has multiple constructors, each calling a more specific constructor in the hierarchy, with the last one calling all the others. This is a common problem in object-oriented programming, and it can make the code hard to read and maintain.

Another problem we have here is that we have many different properties that have the same type. For example, origin and destination are both strings, and departureDate and returnDate are both LocalDate. This can lead to confusion when creating the object. Look at the following client code that creates a `Travel` object for a trip from Milan to New York, departing on October 1st, 2025, and returning on October 15th, 2025, with two passengers, John Doe and Jane Doe:

```java
Travel travel = new Travel(
    "Milan",
    "New York",
    LocalDate.of(2025, 10, 15),
    LocalDate.of(2025, 10, 1),
    2,
    List.of(
        new Passenger(
            "John Doe",
            LocalDate.of(1980, 1, 1),
            "123456789",
            List.of(
                new Ancillary(
                    "Extra Baggage",
                    new Cost(BigDecimal.valueOf(50), Currency.EUR)
                )
            )
        )
    ),
    List.of(
        new Passenger(
            "Jane Doe",
            LocalDate.of(1985, 1, 1),
            "987654321",
            List.of(
                new Ancillary(
                    "Extra Legroom",
                    new Cost(BigDecimal.valueOf(100), Currency.EUR)
                )
            )
        )
    )
);
```

Everything's fine, isn't it? I guess many of you didn't notice that the `departureDate` and `returnDate` are swapped. This is a common mistake that can happen when creating complex objects with many properties of the same type. It's hard to remember the order of the properties, and it's easy to make mistakes, also because we don't have any labels to help us remember the order of the properties.

Another best practice to keep in mind is that we should not expose the internal details of an object to the client code. In particular, we don't want the client code to know the logic of how the object is created. Any validation logic, default values, or constraints should be hidden from the client code. Let's deliberately validate the `Travel` object in the client code:

```java
var travel = Travel(/* ... */)
if (travel.origin() == null) {
    throw new IllegalArgumentException("Origin is required");
}
if (travel.destination() == null) {
    throw new IllegalArgumentException("Destination is required");
}
if (travel.departureDate() == null) {
    throw new IllegalArgumentException("Departure date is required");
}
// ...and so on
```

If we leave the creation of the `Travel` object to the client code, we will end up with a lot of boilerplate code, and the client code will be tightly coupled with the `Travel` object. We will copy and paste the same code over and over again, and if we need to change the `Travel` object, we will have to change all the client code that creates it.
Nevertheless, it's a violation of the DRY (Don't Repeat Yourself) principle.

 We should avoid to create invalid objects in the first place, and we should not expose the internal details of the object to the client code. Then, we can move the validation logic inside the `Travel` primary constructor:

```java
public record Travel(
    String origin,
    String destination,
    LocalDate departureDate,
    LocalDate returnDate,
    int numberOfPassengers,
    List<Passenger> adults,
    List<Passenger> children
) {
    // Compact constructor
    public Travel {
        if (origin == null) {
            throw new IllegalArgumentException("Origin is required");
        }
        if (destination == null) {
            throw new IllegalArgumentException("Destination is required");
        }
        if (departureDate == null) {
            throw new IllegalArgumentException("Departure date is required");
        }
        // ...and so on
    }
}
```

However, as we said, we can have both a one-way and a round-trip flight, we need different validation logic for each case. So, we can't put the validation logic inside the primary constructor.

In the mid 90s, the Builder Pattern was introduced to solve the above problems with the technologies of the time. Let's see how it works.

## Ladies and Gentlemen, the Builder Pattern

The builder pattern addresses quite all the problems we have seen so far. We can cite the book of the Gang of Four to define the pattern:

> Separate the construction of a complex object from its representation so that the same construction process can create different representations.

Let's tackle the definition one sentence at time. The first one says that we need to separate the construction of a complex object from its representation. We can call the object we can build the product of the building process. In our scenario, the product represents the `Travel` class. To adhere to the first part of the definition, we need to avoid clients of the product to build (or instantiate) the product directly. So, first of all, we need to make the `Travel` constructor private. Since `record` classes in Java don't allow private constructors, we must turn the `Travel` type into a regular class:

```java
public class Travel {
    private final String origin;
    private final String destination;
    private final LocalDate departureDate;
    private final LocalDate returnDate;
    private final int numberOfPassengers;
    private final List<Passenger> adults;
    private final List<Passenger> children;

    private Travel(
        String origin,
        String destination,
        LocalDate departureDate,
        LocalDate returnDate,
        int numberOfPassengers,
        List<Passenger> adults,
        List<Passenger> children
    ) {
        this.origin = origin;
        this.destination = destination;
        this.departureDate = departureDate;
        this.returnDate = returnDate;
        this.numberOfPassengers = numberOfPassengers;
        this.adults = adults;
        this.children = children;
    }
}
```

Now, nobody can create a `Travel` object directly. We need to introduce a new class, called the builder, that will be responsible for creating the `Travel` object. The builder class must have access to the private constructor of the `Travel` class. In Java we can achieve this by making the builder class a nested class of the `Travel` class:

```java
public class Travel {
    // Omissis

    public static class Builder {
        // Omissis
        public Travel build() {
            // Omissis
        }
    }
}
```

We also put in the builder type a method to retrieve the `Travel` object. This method is called `build`. The `build` method will be responsible for creating the `Travel` object. However, to create a `Travel` object, we need to set all the properties of the `Travel` object. We can add a method to the builder class for each property of the `Travel` object. Each method will set a property in the `Builder` class and return the builder object itself. This allows us to chain the method calls together. Returning an instance of the `Builder` class itself it's not strictly part of the pattern. This is called a fluent interface. However, it increases the usability of the `Builder`:

```java
public class Travel {
    // Omissis

    public static class Builder {
        private String origin;
        private String destination;
        private LocalDate departureDate;
        private LocalDate returnDate;
        private int numberOfPassengers;
        private List<Passenger> adults = new ArrayList<>();
        private List<Passenger> children = new ArrayList<>();

        public Builder withOrigin(String origin) {
            this.origin = origin;
            return this;
        }

        public Builder withDestination(String destination) {
            this.destination = destination;
            return this;
        }

        public Builder withDepartureDate(LocalDate departureDate) {
            this.departureDate = departureDate;
            return this;
        }

        public Builder withReturnDate(LocalDate returnDate) {
            this.returnDate = returnDate;
            return this;
        }

        public Builder withAdult(Passenger adult) {
            this.adults.add(adult);
            return this;
        }

        public Builder withChild(Passenger child) {
            this.children.add(child);
            return this;
        }

        public Travel build() {
            return new Travel(
                origin,
                destination,
                departureDate,
                returnDate,
                adults.size() + children.size(),
                adults,
                children
            );
        }
    }
}
```

Now, the client code can create a `Travel` object using the builder class. The client code can set only the properties it needs, and the builder class will take care of the rest. The client code doesn't need to know the internal details of the `Travel` object, and the builder class will ensure that the `Travel` object is always in a valid state. The client code can create a `Travel` object like this:

```java
Travel travel = new Travel.Builder()
    .withOrigin("Milan")
    .withDestination("New York")
    .withDepartureDate(LocalDate.of(2025, 10, 1))
    .withReturnDate(LocalDate.of(2025, 10, 15))
    .withAdult(new Passenger(
        "John Doe",
        LocalDate.of(1980, 1, 1),
        "123456789",
        List.of(
            new Ancillary(
                "Extra Baggage",
                new Cost(BigDecimal.valueOf(50), Currency.EUR)
            )
        )
    ))
    .withAdult(new Passenger(
        "Jane Doe",
        LocalDate.of(1985, 1, 1),
        "987654321",
        List.of(
            new Ancillary(
                "Extra Legroom",
                new Cost(BigDecimal.valueOf(100), Currency.EUR)
            )
        )
    ))
    .build();
```

If you remember the solution without the builder pattern it was easy to make the mistake to swap the `departureDate` and `returnDate` (also the `destination` and `origin` properties, to be fair). With the builder pattern, the probability to make this mistake decreases since each method has an explicit and sound name.

It's a common practice to pass to the `Builder` constructor the mandatory properties of the object we want to build. We can change the `Builder` constructor to accept the mandatory properties of the `Travel` object:

```java
public class Travel {
    // Omissis

    public static class Builder {
        private String origin;
        private String destination;
        private LocalDate departureDate;
        private LocalDate returnDate;
        private int numberOfPassengers;
        private List<Passenger> adults = new ArrayList<>();
        private List<Passenger> children = new ArrayList<>();

        // Constructor with mandatory properties
        public Builder(String origin, String destination, LocalDate departureDate) {
            this.origin = origin;
            this.destination = destination;
            this.departureDate = departureDate;
        }

        public Builder withReturnDate(LocalDate returnDate) {
            this.returnDate = returnDate;
            return this;
        }

        public Builder withAdult(Passenger adult) {
            this.adults.add(adult);
            return this;
        }

        public Builder withChild(Passenger child) {
            this.children.add(child);
            return this;
        }

        public Travel build() {
            return new Travel(
                origin,
                destination,
                departureDate,
                returnDate,
                numberOfPassengers,
                adults,
                children
            );
        }
    }
}
```

Speaking abount mandatory properties, we want also to add some validation logic, as we did for the naive solution. We can place the validation logic inside the `build` method, i.e. when we have all the properties set:

```java
public class Travel {
    // Omissis

    public static class Builder {
        // Omissis

        public Travel build() {
            if (origin == null || origin.isBlank()) {
                throw new IllegalStateException("Origin is required");
            }
            if (destination == null || origin.isBlank()) {
                throw new IllegalStateException("Destination is required");
            }
            if (departureDate == null departureDate.isBefore(LocalDate.now())) {
                throw new IllegalStateException("Departure date is required and must be in the future");
            }
            if (returnDate != null && returnDate.isBefore(departureDate)) {
                throw new IllegalStateException("Return date must be after departure date");
            }
            if (adults.isEmpty()) {
                throw new IllegalStateException("At least one adult is required");
            }
            return new Travel(
                origin,
                destination,
                departureDate,
                returnDate,
                adults.size() + children.size(),
                adults,
                children
            );
        }
    }
}
```

Do you remember when we didn't find a way to express the different validations needed by the one-way and round-trip flights with the naive solution? The builder pattern solve the problem by allowing us to define more than one Builder class. We can create a `OneWayTravelBuilder` and a `RoundTripTravelBuilder` class, each with its own validation logic:

TODO
