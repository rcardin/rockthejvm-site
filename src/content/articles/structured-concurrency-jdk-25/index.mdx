---
author: riccardo-cardin
category: guide
title: "Project Loom: Structured Concurrency in JDK 25 - What's New"
excerpt: "Explore the latest evolution of structured concurrency in JDK 25 with JEP 505, featuring the new Joiner API, static factory methods, and enhanced configuration options"
publishedDate: 2025-06-13
tags: [java, loom, concurrency]
---

## Introduction

The journey of structured concurrency in Java continues to evolve. After exploring the fundamentals in our previous article on [Project Loom: Structured Concurrency in Java](https://blog.rockthejvm.com/structured-concurrency-in-java/), we now dive into the significant improvements introduced in the next version of Java, JDK 25. With JEP 505, structured concurrency reaches its fifth preview, bringing substantial API changes that make concurrent programming even more intuitive and powerful.

This article builds upon the concepts we covered previously, focusing on the key differences and new capabilities introduced in JDK 25. If you're new to structured concurrency, I recommend reading the foundational article first to understand the core concepts.

## What's Changed in JDK 25

JDK 25 introduces several fundamental changes to the structured concurrency API through JEP 505:

1. **Static Factory Methods**: `StructuredTaskScope` is now created via static factory methods instead of public constructors
2. **Joiner API**: A new, more flexible way to define completion policies
3. **Enhanced Configuration**: Better support for timeouts, thread factories, and monitoring
4. **Simplified Common Cases**: The zero-parameter `open()` method covers the most common use case
5. **Type Safety Improvements**: Better generic type handling for task results

Let's explore these changes by updating our GitHub user example from the previous article.

## Setting up the project for JDK 25

Since structured concurrency is still in preview in JDK 25, we need to enable preview features. Update your `pom.xml` to target JDK 25:

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.12.1</version>
            <configuration>
                <source>25</source>
                <target>25</target>
                <compilerArgs>
                    <arg>--enable-preview</arg>
                </compilerArgs>
            </configuration>
        </plugin>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-surefire-plugin</artifactId>
            <version>3.2.5</version>
            <configuration>
                <argLine>--enable-preview</argLine>
            </configuration>
        </plugin>
    </plugins>
</build>
```

We'll continue using the same library for logging with an updated version compatible with JDK 25:

```xml
<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
    <version>1.4.14</version>
</dependency>
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>2.0.9</version>
</dependency>
```

At the  time of writing, JDK 25 is still in early access, so make sure to download the latest build from the [OpenJDK website](https://jdk.java.net/25/) and set it up in your IDE. We'll use the build 25-ea+26-3358 for this article.

## The New API: From Constructors to Factory Methods

The most visible change in JDK 25 is how we create `StructuredTaskScope` instances. Instead of using constructors, we now use static factory methods.

Before we dive into the new API, let's quickly recap the main example we used in the previous article: fetching a GitHub user and their repositories concurrently.

First, let's revisit our data structures:

```java
record GitHubUser(User user, List<Repository> repositories) {}

record User(UserId userId, UserName name, Email email) {}

record UserId(long value) {}

record UserName(String value) {}

record Email(String value) {}

record Repository(String name, Visibility visibility, URI uri) {}

enum Visibility {
    PUBLIC,
    PRIVATE
}
```

We also define a logger to help us track the flow of our application:

```java
private static final Logger LOGGER = LoggerFactory.getLogger(Main.class);
```

Next, we have our interfaces for fetching user and repository data:

```java
interface FindUserByIdPort {
  User findUser(UserId userId) throws InterruptedException;
}


interface FindRepositoriesByUserIdPort {
  List<Repository> findRepositories(UserId userId) throws InterruptedException;
}
```

The last piece of the puzzle is the `delay` method, which simulates a delay in the task execution:

```java
void delay(Duration duration) throws InterruptedException {
  Thread.sleep(duration);
}
```

With all the pieces in place, we can give a fake implementation of the `FindUserByIdPort` and `FindRepositoriesByUserIdPort` interfaces to simulate fetching data:

```java
class GitHubRepository implements FindUserByIdPort, FindRepositoriesByUserIdPort {
  @Override
  public User findUser(UserId userId) throws InterruptedException {
    LOGGER.info("Finding user with id '{}'", userId);
    delay(Duration.ofMillis(500L));
    LOGGER.info("User '{}' found", userId);
    return new User(userId, new UserName("rcardin"), new Email("rcardin@rockthejvm.com"));
  }
  @Override
  public List<Repository> findRepositories(UserId userId) throws InterruptedException {
    LOGGER.info("Finding repositories for user with id '{}'", userId);
    delay(Duration.ofSeconds(1L));
    LOGGER.info("Repositories found for user '{}'", userId);
    return List.of(
        new Repository(
            "raise4s", Visibility.PUBLIC, URI.create("https://github.com/rcardin/raise4s")),
        new Repository(
            "sus4s", Visibility.PUBLIC, URI.create("https://github.com/rcardin/sus4s")));
  }
}
```

We compose the `FindUserByIdPort` and `FindRepositoriesByUserIdPort` into a service that fetches a GitHub user and their repositories concurrently, as we did in the previous article:

```java
interface FindGitHubUserUseCase {
  GitHubUser findGitHubUser(UserId userId)
}
```

The best way to understand the changes in JDK 25 is to look at how we create and use `StructuredTaskScope` instances. In previous versions, we used constructors to create scopes, but JDK 25 introduces static factory methods that simplify the API and make it more intuitive. Let's do it step by step.

First, let's create the structured scope that will contain our tasks. In JDK 25, we use the `StructuredTaskScope.open()` method to create a new scope:

```java
class FindGitHubUserService implements FindGitHubUserUseCase {
  private final FindUserByIdPort findUserByIdPort;
  private final FindRepositoriesByUserIdPort findRepositoriesByUserIdPort;

  public FindGitHubUserService(
      FindUserByIdPort findUserByIdPort,
      FindRepositoriesByUserIdPort findRepositoriesByUserIdPort) {
    this.findUserByIdPort = findUserByIdPort;
    this.findRepositoriesByUserIdPort = findRepositoriesByUserIdPort;
  }

  @Override
  public GitHubUser findGitHubUser(UserId userId) {
    try (var scope = StructuredTaskScope.open()) {
      // TODO
      return null;
    }
  }
}
```

Since it's the first time we introduced the new class `FindGitHubUserUseCase`, we shared also the boilerplate code for the data structures and interfaces. We'll omit it in the following sections to focus on the changes introduced in JDK 25.

Do you think the introduction of a static factory method is just a cosmetic change? Not at all! In fact, the returned `StructuredTaskScope` instance is quite different from the previous versions:

```java
// JDK 25 Code Snippet
public sealed interface StructuredTaskScope<T, R> extends AutoCloseable
```

First, the `StructuredTaskScope` bacame an interface instead of a class. But, it's more than just an interface; it's a **sealed interface**. This means that we cannot implement it directly in user site code, as we did in previous versions. We'll return in a moment to this point.

If you remember, the previous version of `StructuredTaskScope` was generic only on the type variable `T`, which represented the type of the result returned by the `join()` method. In JDK 25, the `StructuredTaskScope` interface is now generic on two type variables: `T` and `R`. The `R` type variable represents the type of the result returned by the `join()` method, and the `T` type variable represents the return type of the subtasks that are forked within the scope.

The `open()` method without parameters is particular, since it's defined as follows

```java
// JDK 25 Code Snippet
static <T> StructuredTaskScope<T, Void> open() {
    return open(Joiner.awaitAllSuccessfulOrThrow(), Function.identity());
}
```

We can notice two things. The first, the `R` type variable is bound to `Void`, which means that the `join()` method will not return any value. The only accepted value for `Void` is `null`. The `Void` return type of the joining operation derives from the default joining policy configured by the method, which is the `Joiner.awaitAllSuccessfulOrThrow()`. As we'll see later, instead of explicitly creating the joining policy using a dedicated scope, we'll use the `Joiner` type.

The `Joiner.awaitAllSuccessfulOrThrow()` factory method creates a joining policy comparable to the old `StructuredTaskScope.ShutdownOnFailure` class, which was used to define the default behavior of the scope: "succeed if all subtasks succeed, fail if any subtask fails." This is the most common use case in structured concurrency. In such a policy, the `join()` method always returns `null` if all subtasks succeed.

Now, we need to create the subtasks. Nothing changes here; we can still use the `fork()` method to create subtasks within the scope.

```java
try (var scope = StructuredTaskScope.open()) {
  var user = scope.fork(() -> findUserByIdPort.findUser(userId));
  var repositories = scope.fork(() -> findRepositoriesByUserIdPort.findRepositories(userId));

  return null;
}
```

After forking the subtasks, we need to wait for them to complete. In JDK 25, as in the previous installments, we can use the `join()` method to wait for all subtasks to complete or any to fail:

```java
try (var scope = StructuredTaskScope.open()) {
  var user = scope.fork(() -> findUserByIdPort.findUser(userId));
  var repositories = scope.fork(() -> findRepositoriesByUserIdPort.findRepositories(userId));

  scope.join();

  return null;
}
```

Last but not least, we need to retrieve the results of the subtasks, calling the `get()` method on the `Subtask` instances returned by the `fork()` method:

```java
try (var scope = StructuredTaskScope.open()) {
  var user = scope.fork(() -> findUserByIdPort.findUser(userId));
  var repositories = scope.fork(() -> findRepositoriesByUserIdPort.findRepositories(userId));

  scope.join();

  return new GitHubUser(user.get(), repositories.get());;
}
```

Again, nothing changes here, apparently. The only difference is the type of the exception thrown by the `join()` method. In JDK 25, if any subtask fails, the `join()` method throws a `StructuredTaskScope.FailedException`, which wraps the original exception thrown by the failing subtask. If you remember, in the previous versions, the `join()` method threw a `java.util.concurrent.ExecutionException`.

Now, that we saw the basic usage of the new API, let's explore the key differences in the concurrency policies introduced in JDK 25.

## Meet Your New Best Friend: The `Joiner` API

As we saw, the `StructuredTaskScope` in JDK 25 is a sealed interface, which means we cannot implement it directly. Moreover, the interface has only one implementation, which doesn't implement any concurrency policy. In previous versions, we had different implementations of `StructuredTaskScope` that defined different concurrency policies, such as `ShutdownOnFailure`, `ShutdownOnSuccess`, and so on. How are concurrency policies defined in JDK 25, then?

In JDK 25, concurrency policies are defined through a new API called `Joiner`. The `Joiner` API allows us to define how the results of subtasks are combined and how failures are handled.

The JDK offers a set of built-in joiners that cover the most common use cases, and are available as static factory methods on the `Joiner` interface. Let's take a look at how we can use these joiners to define the behavior of our structured task scope.

The first `Joiner` we see is the `Joiner.AwaitSuccessful<T>`. It's the default joiner used by the `StructuredTaskScope.open()` method without parameters. It waits for all subtasks to complete successfully, and if any subtask fails, it throws a `StructuredTaskScope.FailedException`. We can create an instance of such a joiner by calling the static factory method `Joiner.awaitAllSuccessfulOrThrow()`:

```java
// JDK 25 Code Snippet
static <T> Joiner<T, Void> awaitAllSuccessfulOrThrow() {
    return new Joiners.AwaitSuccessful<>();
}
```

The `AwaitSuccessful<T>` joiner is the counterpart of the `ShutdownOnFailure` class we used in previous versions.

As we saw earlier, the return type `R` of the `Joiner` is bound to `Void`, which means that the `join()` method will return `null` if all subtasks succeed. If any subtask fails, the `join()` method will throw a `StructuredTaskScope.FailedException`.

To see it in action in case of a failure in one of the subtasks, let's modify our `GitHubRepository.findUser` method to simulate a failure:

```java
@Override
public User findUser(UserId userId) throws InterruptedException {
  LOGGER.info("Finding user with id '{}'", userId);
  delay(Duration.ofMillis(500L));
  throw new RuntimeException("Error finding user with id '%s'".formatted(userId));
}
```

Let's wire all the pieces together in the `main` method:

```java
void main() throws InterruptedException {
  var gitHubRepository = new GitHubRepository();
  var findGitHubUserService = new FindGitHubUserService(gitHubRepository, gitHubRepository);
  findGitHubUserService.findGitHubUser(new UserId(1L));
}
```

When we run the `main` method, we should see the following output:

```
14:52:27.097 [] INFO  in.rcard.sc.Main - Finding user with id 'UserId[value=1]'
14:52:27.097 [] INFO  in.rcard.sc.Main - Finding repositories for user with id 'UserId[value=1]'
Exception in thread "main" java.util.concurrent.StructuredTaskScope$FailedException: java.lang.RuntimeException: Error finding user with id 'UserId[value=1]'
	at java.base/java.util.concurrent.StructuredTaskScopeImpl.join(StructuredTaskScopeImpl.java:258)
	at in.rcard.sc.Main$FindGitHubUserService.findGitHubUser(Main.java:89)
	at in.rcard.sc.Main.main(Main.java:101)
Caused by: java.lang.RuntimeException: Error finding user with id 'UserId[value=1]'
	at in.rcard.sc.Main$GitHubRepository.findUser(Main.java:48)
	at in.rcard.sc.Main$FindGitHubUserService.lambda$findGitHubUser$0(Main.java:86)
	at java.base/java.util.concurrent.StructuredTaskScopeImpl$SubtaskImpl.run(StructuredTaskScopeImpl.java:325)
	at java.base/java.lang.VirtualThread.run(VirtualThread.java:456)
```

As expected, the `join()` method throws a `StructuredTaskScope.FailedException`, which wraps the original exception thrown by the failing subtask. Moreover, the `repositories` forked subtask is cancelled, as the concurrency policy promised.

If you remember, in the previous versions, when using the the `StructuredTaskScope.ShutdownOnFailure` class, we had to call also the `throwIfFailed()` method in chain to the `join()` method. In JDK 25, the designers reviewed the API opting for an homogeneous approach among the different concurrency policies. In this way, we lost the possibility to remap the exception thrown by the `join()` method, which was possible in previous versions since the `throwIfFailed()` could had taken a mapping function as parameter. However, in the previous article, we warned about remapping the original exception thrown by the failing subtask, since it was a `Throwable` that potentially could have been an `Error`.

















The `Joiner` interface is a functional interface that defines a single method purely abstract method:

```java
// JDK 25 Code Snippet
public interface Joiner<T, R> {
    R result() throws Throwable;
}
```

As you might guess, the `join()` internally invokes the the `result()` method of the `Joiner` instance to retrieve the final result of the scope.

```java
// JDK 25 Code Snippet
@Override
public R join() throws InterruptedException {
    // A lot of code here...
    try {
        return joiner.result();
    } catch (Throwable e) {
        throw new FailedException(e);
    }
}
```

The `Joiner` interface is generic also on `T` other than `R`. The `T` type variable represents the type of the subtasks, as we saw earlier. The `Joiner` uses the type variable `T` the remaining methods it exposes:

```java
// JDK 25 Code Snippet
default boolean onFork(Subtask<? extends T> subtask) {
    if (subtask.state() != Subtask.State.UNAVAILABLE) {
        throw new IllegalArgumentException("Subtask not in UNAVAILABLE state");
    }
    return false;
}

default boolean onComplete(Subtask<? extends T> subtask) {
    if (subtask.state() == Subtask.State.UNAVAILABLE) {
        throw new IllegalArgumentException("Subtask has not completed");
    }
    return false;
}
```

As the names suggest, the `onFork()` method is called when a subtask is forked, and the `onComplete()` method is called when a subtask completes. Both methods return a boolean value that indicates whether the outer scope should be cancelled or not. Be careful, though: the `onComplete` method is not called if the subtask completes after the outer scope has been cancelled.















### Built-in Joiners

JDK 25 provides several built-in joiners for common patterns:

#### 1. allSuccessfulOrThrow()

This joiner waits for all subtasks to succeed and returns a stream of all subtasks:

```java
public List<Repository> findAllRepositoriesFromMultipleSources(UserId userId) throws InterruptedException {
    List<FindRepositoriesByUserIdPort> sources = getRepositorySources();

    try (var scope = StructuredTaskScope.open(Joiner.allSuccessfulOrThrow())) {
        // Fork a task for each source
        sources.forEach(source -> scope.fork(() -> source.findRepositories(userId)));

        // Get all results and flatten them
        return scope.join()
                    .map(Subtask::get)
                    .flatMap(List::stream)
                    .distinct()
                    .toList();
    }
}
```

#### 2. anySuccessfulResultOrThrow()

This joiner implements a "race" pattern - it returns the result of the first subtask that succeeds:

```java
public List<Repository> findRepositoriesWithFallback(UserId userId) throws InterruptedException {
    try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulResultOrThrow())) {
        // Try cache first
        scope.fork(() -> cacheService.findRepositories(userId));
        // Fallback to API
        scope.fork(() -> apiService.findRepositories(userId));

        // Returns the result of whichever completes successfully first
        return scope.join();
    }
}
```

#### 3. awaitAll()

This joiner waits for all subtasks to complete, regardless of success or failure:

```java
public void performCleanupTasks(UserId userId) throws InterruptedException {
    try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {
        scope.fork(() -> cacheService.invalidateUser(userId));
        scope.fork(() -> logService.logUserAccess(userId));
        scope.fork(() -> analyticsService.trackUserActivity(userId));

        scope.join(); // Waits for all to complete

        // Process individual results as needed
        // All subtasks are guaranteed to be complete
    }
}
```

## Custom Joiners: Advanced Policies

The real power comes from implementing custom joiners. Let's create a joiner that collects successful results while ignoring failures:

```java
public class CollectSuccessfulJoiner<T> implements StructuredTaskScope.Joiner<T, List<T>> {
    private final List<T> results = Collections.synchronizedList(new ArrayList<>());
    private volatile boolean cancelled = false;

    @Override
    public boolean onComplete(StructuredTaskScope.Subtask<? extends T> subtask) {
        if (subtask.state() == StructuredTaskScope.Subtask.State.SUCCESS) {
            results.add(subtask.get());
        }
        // Never cancel - we want to collect all successful results
        return false;
    }

    @Override
    public List<T> result() throws Throwable {
        return new ArrayList<>(results);
    }
}
```

Using this custom joiner:

```java
public List<Repository> findRepositoriesFromAllAvailableSources(UserId userId) throws InterruptedException {
    List<FindRepositoriesByUserIdPort> sources = getAllRepositorySources();

    try (var scope = StructuredTaskScope.open(new CollectSuccessfulJoiner<List<Repository>>())) {
        // Fork tasks for all sources - some might fail
        sources.forEach(source -> scope.fork(() -> source.findRepositories(userId)));

        // Get all successful results, ignoring failures
        return scope.join()
                    .stream()
                    .flatMap(List::stream)
                    .distinct()
                    .toList();
    }
}
```

## Enhanced Configuration

JDK 25 introduces powerful configuration options through the `Config` API:

### Setting Timeouts

```java
public GitHubUser findGitHubUserWithTimeout(UserId userId, Duration timeout)
    throws InterruptedException {

    try (var scope = StructuredTaskScope.open(
            Joiner.allSuccessfulOrThrow(),
            config -> config.withTimeout(timeout))) {

        var userTask = scope.fork(() -> findUserByIdPort.findUser(userId));
        var repositoriesTask = scope.fork(() -> findRepositoriesByUserIdPort.findRepositories(userId));

        scope.join(); // Will throw TimeoutException if timeout expires

        return new GitHubUser(
            userTask.get(),
            repositoriesTask.get().map(Subtask::get).toList().get(0) // Example extraction
        );
    }
}
```

### Custom Thread Factory

```java
public GitHubUser findGitHubUserWithCustomThreads(UserId userId) throws InterruptedException {
    ThreadFactory customFactory = Thread.ofVirtual()
        .name("github-worker-", 0)
        .factory();

    try (var scope = StructuredTaskScope.open(
            Joiner.allSuccessfulOrThrow(),
            config -> config.withThreadFactory(customFactory)
                           .withName("github-user-scope"))) {

        var userTask = scope.fork(() -> findUserByIdPort.findUser(userId));
        var repositoriesTask = scope.fork(() -> findRepositoriesByUserIdPort.findRepositories(userId));

        scope.join();

        return new GitHubUser(userTask.get(), repositoriesTask.get());
    }
}
```

## Practical Example: Building a Resilient Service

Let's create a comprehensive example that showcases the new capabilities:

```java
public class ResilientGitHubService {
    private static final Logger LOGGER = LoggerFactory.getLogger(ResilientGitHubService.class);

    private final List<FindUserByIdPort> userSources;
    private final List<FindRepositoriesByUserIdPort> repositorySources;
    private final Duration defaultTimeout = Duration.ofSeconds(5);

    public GitHubUser findGitHubUserResilient(UserId userId) throws InterruptedException {
        try (var scope = StructuredTaskScope.open(
                Joiner.allSuccessfulOrThrow(),
                config -> config.withTimeout(defaultTimeout)
                               .withName("resilient-github-lookup"))) {

            // Find user with fallback sources
            var userTask = scope.fork(() -> findUserWithFallback(userId));

            // Find repositories with multiple sources
            var repositoriesTask = scope.fork(() -> findRepositoriesResilient(userId));

            scope.join();

            return new GitHubUser(userTask.get(), repositoriesTask.get());
        }
    }

    private User findUserWithFallback(UserId userId) throws InterruptedException {
        try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulResultOrThrow())) {
            // Try all user sources, return first successful result
            userSources.forEach(source -> scope.fork(() -> source.findUser(userId)));
            return scope.join();
        }
    }

    private List<Repository> findRepositoriesResilient(UserId userId) throws InterruptedException {
        try (var scope = StructuredTaskScope.open(new CollectSuccessfulJoiner<List<Repository>>())) {
            // Try all repository sources, collect all successful results
            repositorySources.forEach(source -> scope.fork(() -> source.findRepositories(userId)));

            return scope.join()
                        .stream()
                        .flatMap(List::stream)
                        .distinct()
                        .toList();
        }
    }
}
```

## Exception Handling in JDK 25

Exception handling becomes more straightforward with the new API:

```java
public GitHubUser findGitHubUserWithErrorHandling(UserId userId) {
    try (var scope = StructuredTaskScope.open()) {
        var userTask = scope.fork(() -> findUserByIdPort.findUser(userId));
        var repositoriesTask = scope.fork(() -> findRepositoriesByUserIdPort.findRepositories(userId));

        scope.join();

        return new GitHubUser(userTask.get(), repositoriesTask.get());

    } catch (StructuredTaskScope.FailedException e) {
        // Handle failures from subtasks
        Throwable cause = e.getCause();
        LOGGER.error("Failed to fetch GitHub user data", cause);

        return switch (cause) {
            case UserNotFoundException unf -> throw new IllegalArgumentException("User not found: " + userId);
            case NetworkException ne -> throw new ServiceUnavailableException("Network error", ne);
            default -> throw new RuntimeException("Unexpected error", cause);
        };

    } catch (StructuredTaskScope.TimeoutException e) {
        LOGGER.warn("Request timed out for user: {}", userId);
        throw new RequestTimeoutException("Request timed out");

    } catch (InterruptedException e) {
        Thread.currentThread().interrupt();
        throw new RuntimeException("Request was interrupted", e);
    }
}
```

## Migration Guide from Java 21/23 to JDK 25

If you're migrating from the previous structured concurrency API, here's a quick reference:

### Basic Scope Creation
```java
// Old (Java 21/23)
try (var scope = new StructuredTaskScope<>()) { }

// New (JDK 25)
try (var scope = StructuredTaskScope.open()) { }
```

### Shutdown on Failure Policy
```java
// Old
try (var scope = new StructuredTaskScope.ShutdownOnFailure()) {
    // ...
    scope.join().throwIfFailed();
}

// New
try (var scope = StructuredTaskScope.open()) {
    // ...
    scope.join(); // Automatically throws FailedException on failure
}
```

### Shutdown on Success Policy
```java
// Old
try (var scope = new StructuredTaskScope.ShutdownOnSuccess<String>()) {
    // ...
    return scope.join().result();
}

// New
try (var scope = StructuredTaskScope.open(Joiner.anySuccessfulResultOrThrow())) {
    // ...
    return scope.join();
}
```

## Observability Improvements

JDK 25 enhances observability with better thread dump support. The hierarchical structure of scopes is now clearly visible in JSON thread dumps:

```bash
jcmd <pid> Thread.dump_to_file -format=json thread_dump.json
```

This will show the structured relationship between parent and child tasks, making debugging concurrent applications much easier.

## Performance Considerations

The new API brings several performance benefits:

1. **Reduced Object Allocation**: Static factory methods reduce the overhead of scope creation
2. **Better Memory Management**: Joiners can be optimized for specific use cases
3. **Enhanced Virtual Thread Integration**: Better integration with virtual threads' lifecycle management

## Best Practices for JDK 25 Structured Concurrency

1. **Use the Default Policy When Possible**: The zero-parameter `open()` method covers most use cases
2. **Leverage Built-in Joiners**: Before creating custom joiners, check if built-in ones meet your needs
3. **Configure Timeouts**: Always set reasonable timeouts for external operations
4. **Handle Interruption Properly**: Ensure your subtasks respond to interruption
5. **Use Descriptive Names**: Set meaningful names for scopes to improve observability

## Conclusion

JDK 25's structured concurrency represents a significant evolution from the previous versions. The new `Joiner` API provides unprecedented flexibility while maintaining the simplicity that makes structured concurrency so appealing. The static factory methods and enhanced configuration options make the API more intuitive and powerful.

The journey from unstructured concurrency with `ExecutorService` to the elegant structured concurrency of JDK 25 shows how Java continues to evolve to meet the needs of modern concurrent programming. Virtual threads provide the scalability, and structured concurrency provides the safety and clarity we need to build robust, maintainable applications.

As structured concurrency moves towards finalization in future Java releases, now is the perfect time to start experimenting with these new APIs and integrating them into your applications. The combination of virtual threads and structured concurrency represents the future of concurrent programming in Java, offering both performance and maintainability that traditional approaches simply cannot match.

The concepts we've explored here - from basic scope creation to custom joiners and resilient service patterns - provide a solid foundation for building the next generation of concurrent Java applications. As you adopt these patterns, you'll find that concurrent programming becomes not just more performant, but also more enjoyable and less error-prone.
