---
author: riccardo-cardin
category: guide
title: "Project Loom: Structured Concurrency in JDK 25 - What's New"
excerpt: "Explore the latest evolution of structured concurrency in JDK 25 with JEP 505, featuring the new Joiner API, static factory methods, and enhanced configuration options"
publishedDate: 2025-06-13
tags: [java, loom, concurrency]
---

## Introduction

The journey of structured concurrency in Java continues to evolve. After exploring the fundamentals in our previous article on [Project Loom: Structured Concurrency in Java](https://blog.rockthejvm.com/structured-concurrency-in-java/), we now dive into the significant improvements introduced in the next version of Java, JDK 25. With JEP 505, structured concurrency reaches its fifth preview, bringing substantial API changes that make concurrent programming even more intuitive and powerful.

This article builds upon the concepts we covered previously, focusing on the key differences and new capabilities introduced in JDK 25. If you're new to structured concurrency, I recommend reading the foundational article first to understand the core concepts.

## What's Changed in JDK 25

JDK 25 introduces several fundamental changes to the structured concurrency API through JEP 505:

1. **Static Factory Methods**: `StructuredTaskScope` is now created via static factory methods instead of public constructors
2. **Joiner API**: A new, more flexible way to define completion policies
3. **Enhanced Configuration**: Better support for timeouts, thread factories, and monitoring
4. **Simplified Common Cases**: The zero-parameter `open()` method covers the most common use case
5. **Type Safety Improvements**: Better generic type handling for task results

Let's explore these changes by updating our GitHub user example from the previous article.

## Setting up the project for JDK 25

Since structured concurrency is still in preview in JDK 25, we need to enable preview features. Update your `pom.xml` to target JDK 25:

```xml
<build>
    <plugins>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-compiler-plugin</artifactId>
            <version>3.12.1</version>
            <configuration>
                <source>25</source>
                <target>25</target>
                <compilerArgs>
                    <arg>--enable-preview</arg>
                </compilerArgs>
            </configuration>
        </plugin>
        <plugin>
            <groupId>org.apache.maven.plugins</groupId>
            <artifactId>maven-surefire-plugin</artifactId>
            <version>3.2.5</version>
            <configuration>
                <argLine>--enable-preview</argLine>
            </configuration>
        </plugin>
    </plugins>
</build>
```

We'll continue using the same library for logging with an updated version compatible with JDK 25:

```xml
<dependency>
    <groupId>ch.qos.logback</groupId>
    <artifactId>logback-classic</artifactId>
    <version>1.5.13</version>
</dependency>
<dependency>
    <groupId>org.slf4j</groupId>
    <artifactId>slf4j-api</artifactId>
    <version>2.0.9</version>
</dependency>
```

At the  time of writing, JDK 25 is still in early access, so make sure to download the latest build from the [OpenJDK website](https://jdk.java.net/25/) and set it up in your IDE. We'll use the build 25-ea+26-3358 for this article.

## The New API: From Constructors to Factory Methods

The most visible change in JDK 25 is how we create `StructuredTaskScope` instances. Instead of using constructors, we now use static factory methods.

Before we dive into the new API, let's quickly recap the main example we used in the previous article: fetching a GitHub user and their repositories concurrently.

First, let's revisit our data structures:

```java
record GitHubUser(User user, List<Repository> repositories) {}

record User(UserId userId, UserName name, Email email) {}

record UserId(long value) {}

record UserName(String value) {}

record Email(String value) {}

record Repository(String name, Visibility visibility, URI uri) {}

enum Visibility {
    PUBLIC,
    PRIVATE
}
```

We also define a logger to help us track the flow of our application:

```java
private static final Logger LOGGER = LoggerFactory.getLogger(Main.class);
```

Next, we have our interfaces for fetching user and repository data:

```java
interface FindUserByIdPort {
  User findUser(UserId userId) throws InterruptedException;
}


interface FindRepositoriesByUserIdPort {
  List<Repository> findRepositories(UserId userId) throws InterruptedException;
}
```

The last piece of the puzzle is the `delay` method, which simulates a delay in the task execution:

```java
void delay(Duration duration) throws InterruptedException {
  Thread.sleep(duration);
}
```

With all the pieces in place, we can give a fake implementation of the `FindUserByIdPort` and `FindRepositoriesByUserIdPort` interfaces to simulate fetching data:

```java
class GitHubRepository implements FindUserByIdPort, FindRepositoriesByUserIdPort {
  @Override
  public User findUser(UserId userId) throws InterruptedException {
    LOGGER.info("Finding user with id '{}'", userId);
    delay(Duration.ofMillis(500L));
    LOGGER.info("User '{}' found", userId);
    return new User(userId, new UserName("rcardin"), new Email("rcardin@rockthejvm.com"));
  }
  @Override
  public List<Repository> findRepositories(UserId userId) throws InterruptedException {
    LOGGER.info("Finding repositories for user with id '{}'", userId);
    delay(Duration.ofSeconds(1L));
    LOGGER.info("Repositories found for user '{}'", userId);
    return List.of(
        new Repository(
            "raise4s", Visibility.PUBLIC, URI.create("https://github.com/rcardin/raise4s")),
        new Repository(
            "sus4s", Visibility.PUBLIC, URI.create("https://github.com/rcardin/sus4s")));
  }
}
```

We compose the `FindUserByIdPort` and `FindRepositoriesByUserIdPort` into a service that fetches a GitHub user and their repositories concurrently, as we did in the previous article:

```java
interface FindGitHubUserUseCase {
  GitHubUser findGitHubUser(UserId userId)
}
```

The best way to understand the changes in JDK 25 is to look at how we create and use `StructuredTaskScope` instances. In previous versions, we used constructors to create scopes, but JDK 25 introduces static factory methods that simplify the API and make it more intuitive. Let's do it step by step.

First, let's create the structured scope that will contain our tasks. In JDK 25, we use the `StructuredTaskScope.open()` method to create a new scope:

```java
class FindGitHubUserService implements FindGitHubUserUseCase {
  private final FindUserByIdPort findUserByIdPort;
  private final FindRepositoriesByUserIdPort findRepositoriesByUserIdPort;

  public FindGitHubUserService(
      FindUserByIdPort findUserByIdPort,
      FindRepositoriesByUserIdPort findRepositoriesByUserIdPort) {
    this.findUserByIdPort = findUserByIdPort;
    this.findRepositoriesByUserIdPort = findRepositoriesByUserIdPort;
  }

  @Override
  public GitHubUser findGitHubUser(UserId userId) {
    try (var scope = StructuredTaskScope.open()) {
      // TODO
      return null;
    }
  }
}
```

Since it's the first time we introduced the new class `FindGitHubUserUseCase`, we shared also the boilerplate code for the data structures and interfaces. We'll omit it in the following sections to focus on the changes introduced in JDK 25.

Do you think the introduction of a static factory method is just a cosmetic change? Not at all! In fact, the returned `StructuredTaskScope` instance is quite different from the previous versions:

```java
// JDK 25 Code Snippet
public sealed interface StructuredTaskScope<T, R> extends AutoCloseable
```

First, the `StructuredTaskScope` bacame an interface instead of a class. But, it's more than just an interface; it's a **sealed interface**. This means that we cannot implement it directly in user site code, as we did in previous versions. We'll return in a moment to this point.

If you remember, the previous version of `StructuredTaskScope` was generic only on the type variable `T`, which represented the type of the result returned by the `join()` method. In JDK 25, the `StructuredTaskScope` interface is now generic on two type variables: `T` and `R`. The `R` type variable represents the type of the result returned by the `join()` method, and the `T` type variable represents the return type of the subtasks that are forked within the scope.

The `open()` method without parameters is particular, since it's defined as follows

```java
// JDK 25 Code Snippet
static <T> StructuredTaskScope<T, Void> open() {
    return open(Joiner.awaitAllSuccessfulOrThrow(), Function.identity());
}
```

We can notice two things. The first, the `R` type variable is bound to `Void`, which means that the `join()` method will not return any value. The only accepted value for `Void` is `null`. The `Void` return type of the joining operation derives from the default joining policy configured by the method, which is the `Joiner.awaitAllSuccessfulOrThrow()`. As we'll see later, instead of explicitly creating the joining policy using a dedicated scope, we'll use the `Joiner` type.

The `Joiner.awaitAllSuccessfulOrThrow()` factory method creates a joining policy comparable to the old `StructuredTaskScope.ShutdownOnFailure` class, which was used to define the default behavior of the scope: "succeed if all subtasks succeed, fail if any subtask fails." This is the most common use case in structured concurrency. In such a policy, the `join()` method always returns `null` if all subtasks succeed.

Now, we need to create the subtasks. Nothing changes here; we can still use the `fork()` method to create subtasks within the scope.

```java
try (var scope = StructuredTaskScope.open()) {
  var user = scope.fork(() -> findUserByIdPort.findUser(userId));
  var repositories = scope.fork(() -> findRepositoriesByUserIdPort.findRepositories(userId));

  return null;
}
```

After forking the subtasks, we need to wait for them to complete. In JDK 25, as in the previous installments, we can use the `join()` method to wait for all subtasks to complete or any to fail:

```java
try (var scope = StructuredTaskScope.open()) {
  var user = scope.fork(() -> findUserByIdPort.findUser(userId));
  var repositories = scope.fork(() -> findRepositoriesByUserIdPort.findRepositories(userId));

  scope.join();

  return null;
}
```

Last but not least, we need to retrieve the results of the subtasks, calling the `get()` method on the `Subtask` instances returned by the `fork()` method:

```java
try (var scope = StructuredTaskScope.open()) {
  var user = scope.fork(() -> findUserByIdPort.findUser(userId));
  var repositories = scope.fork(() -> findRepositoriesByUserIdPort.findRepositories(userId));

  scope.join();

  return new GitHubUser(user.get(), repositories.get());;
}
```

Again, nothing changes here, apparently. The only difference is the type of the exception thrown by the `join()` method. In JDK 25, if any subtask fails, the `join()` method throws a `StructuredTaskScope.FailedException`, which wraps the original exception thrown by the failing subtask. If you remember, in the previous versions, the `join()` method threw a `java.util.concurrent.ExecutionException`. The main difference between the two is that the `FailedException` is a unchecked exception, while the `ExecutionException` is an checked exception.

Now, that we saw the basic usage of the new API, let's explore the key differences in the concurrency policies introduced in JDK 25.

## Meet Your New Best Friend: The `Joiner` API

As we saw, the `StructuredTaskScope` in JDK 25 is a sealed interface, which means we cannot implement it directly. Moreover, the interface has only one implementation, which doesn't implement any concurrency policy. In previous versions, we had different implementations of `StructuredTaskScope` that defined different concurrency policies, such as `ShutdownOnFailure`, `ShutdownOnSuccess`, and so on. How are concurrency policies defined in JDK 25, then?

In JDK 25, concurrency policies are defined through a new API called `Joiner`. The `Joiner` API allows us to define how the results of subtasks are combined and how failures are handled.

The JDK offers a set of built-in joiners that cover the most common use cases, and are available as static factory methods on the `Joiner` interface. Let's take a look at how we can use these joiners to define the behavior of our structured task scope.

The first `Joiner` we see is the `Joiner.AwaitSuccessful<T>`. It's the default joiner used by the `StructuredTaskScope.open()` method without parameters. It waits for all subtasks to complete successfully, and if any subtask fails, it throws a `StructuredTaskScope.FailedException`. We can create an instance of such a joiner by calling the static factory method `Joiner.awaitAllSuccessfulOrThrow()`:

```java
// JDK 25 Code Snippet
static <T> Joiner<T, Void> awaitAllSuccessfulOrThrow() {
    return new Joiners.AwaitSuccessful<>();
}
```

The `AwaitSuccessful<T>` joiner is the counterpart of the `ShutdownOnFailure` class we used in previous versions.

As we saw earlier, the return type `R` of the `Joiner` is bound to `Void`, which means that the `join()` method will return `null` if all subtasks succeed. If any subtask fails, the `join()` method will throw a `StructuredTaskScope.FailedException`.

To see it in action in case of a failure in one of the subtasks, let's modify our `GitHubRepository.findUser` method to simulate a failure:

```java
@Override
public User findUser(UserId userId) throws InterruptedException {
  LOGGER.info("Finding user with id '{}'", userId);
  delay(Duration.ofMillis(500L));
  throw new RuntimeException("Error finding user with id '%s'".formatted(userId));
}
```

Let's wire all the pieces together in the `main` method:

```java
void main() throws InterruptedException {
  var gitHubRepository = new GitHubRepository();
  var findGitHubUserService = new FindGitHubUserService(gitHubRepository, gitHubRepository);
  findGitHubUserService.findGitHubUser(new UserId(1L));
}
```

When we run the `main` method, we should see the following output:

```
14:52:27.097 [virtual-12] INFO  in.rcard.sc.Main - Finding user with id 'UserId[value=1]'
14:52:27.097 [virtual-12] INFO  in.rcard.sc.Main - Finding repositories for user with id 'UserId[value=1]'
Exception in thread "main" java.util.concurrent.StructuredTaskScope$FailedException: java.lang.RuntimeException: Error finding user with id 'UserId[value=1]'
	at java.base/java.util.concurrent.StructuredTaskScopeImpl.join(StructuredTaskScopeImpl.java:258)
	at in.rcard.sc.Main$FindGitHubUserService.findGitHubUser(Main.java:89)
	at in.rcard.sc.Main.main(Main.java:101)
Caused by: java.lang.RuntimeException: Error finding user with id 'UserId[value=1]'
	at in.rcard.sc.Main$GitHubRepository.findUser(Main.java:48)
	at in.rcard.sc.Main$FindGitHubUserService.lambda$findGitHubUser$0(Main.java:86)
	at java.base/java.util.concurrent.StructuredTaskScopeImpl$SubtaskImpl.run(StructuredTaskScopeImpl.java:325)
	at java.base/java.lang.VirtualThread.run(VirtualThread.java:456)
```

As expected, the `join()` method throws a `StructuredTaskScope.FailedException`, which wraps the original exception thrown by the failing subtask. Moreover, the `repositories` forked subtask is cancelled, as the concurrency policy promised.

If you remember, in the previous versions, when using the the `StructuredTaskScope.ShutdownOnFailure` class, we had to call also the `throwIfFailed()` method in chain to the `join()` method. In JDK 25, the designers reviewed the API opting for an homogeneous approach among the different concurrency policies. In this way, we lost the possibility to remap the exception thrown by the `join()` method, which was possible in previous versions since the `throwIfFailed()` could had taken a mapping function as parameter. However, in the previous article, we warned about remapping the original exception thrown by the failing subtask, since it was a `Throwable` that potentially could have been an `Error`.


The second joiner we see is a slightly different version of the previous one, called `AllSuccessful<T>`:

```java
// JDK 25 Code Snippet
static final class AllSuccessful<T> implements Joiner<T, Stream<Subtask<T>>>
```

The class signature should tell you quite soundly what it does: it waits for all subtasks to complete successfully, and returns a stream of all subtasks. If any subtask fails, it throws a `StructuredTaskScope.FailedException` and cancel any left subtask. All subtasks must returns a value of type `T` or a subtype of it.

We can create an instance of this joiner by calling the static factory method `Joiner.allSuccessfulOrThrow()`. So, let's make an example. Let's say we want to fetch concurrently a list of users:

```java
interface FindGitHubUsersUseCase {
  List<GitHubUser> findGitHubUsers(List<UserId> userIds) throws InterruptedException;
}
```

The service implementing this use case can be defined as follows:

```java
class FindGitHubUsersService implements FindGitHubUsersUseCase {

  private final FindGitHubUserUseCase findGitHubUser;

  FindGitHubUsersService(FindGitHubUserUseCase findGitHubUser) {
    this.findGitHubUser = findGitHubUser;
  }

  @Override
  public List<GitHubUser> findGitHubUsers(List<UserId> userIds) throws InterruptedException {
    try (var scope = StructuredTaskScope.open(Joiner.<GitHubUser>allSuccessfulOrThrow())) {
      userIds.forEach(userId -> scope.fork(() -> findGitHubUser.findGitHubUser(userId)));
      return scope.join().map(StructuredTaskScope.Subtask::get).toList();
    }
  }
}
```

Since we're not unsing the default joiner, we need to pass it explicitly to the `StructuredTaskScope.open()` method. We can now use our newly shiny service to fetch a list of GitHub users:

```java
void main() throws InterruptedException {
  var gitHubRepository = new GitHubRepository();
  var findGitHubUserService = new FindGitHubUserService(gitHubRepository, gitHubRepository);
  var findGitHubUsersService = new FindGitHubUsersService(findGitHubUserService);
  findGitHubUsersService.findGitHubUsers(List.of(new UserId(1L), new UserId(2L)));
}
```

When we run the `main` method, we should see the following output:

```
18:18:29.406 [virtual-29] INFO  in.rcard.sc.Main - Finding user with id 'UserId[value=2]'
18:18:29.406 [virtual-33] INFO  in.rcard.sc.Main - Finding repositories for user with id 'UserId[value=2]'
18:18:29.406 [virtual-30] INFO  in.rcard.sc.Main - Finding user with id 'UserId[value=1]'
18:18:29.406 [virtual-34] INFO  in.rcard.sc.Main - Finding repositories for user with id 'UserId[value=1]'
18:18:29.919 [virtual-29] INFO  in.rcard.sc.Main - User 'UserId[value=2]' found
18:18:29.919 [virtual-30] INFO  in.rcard.sc.Main - User 'UserId[value=1]' found
18:18:30.422 [virtual-33] INFO  in.rcard.sc.Main - Repositories found for user 'UserId[value=2]'
18:18:30.422 [virtual-34] INFO  in.rcard.sc.Main - Repositories found for user 'UserId[value=1]'
```

As we can see, the executions of the two subtasks are interleaved, and the results are returned as a list of `GitHubUser` instances. It's very interesting also to look at the list of virtual threads that are executing the subtasks.

The next joiner we see is the `AnySuccessful<T>` joiner:

```java
static final class AnySuccessful<T> implements Joiner<T, T>
```

The joiner is the new version of the `StructuredTaskScope.ShutdownOnSuccess` class we used in previous versions. It waits for any subtask to complete successfully, and returns the result of the first successful subtask. The remaining subtasks are properly cancelled. If all subtasks fail, it throws a `StructuredTaskScope.FailedException`. We can retrieve an instance of this joiner by calling the static factory method `Joiner.anySuccessfulResultOrThrow()`.

If you remember, in the previous article we simulate the two subtasks that fetch a GitHub user repository from a cache and from GitHub directly. The first tasks that succeeds returns its result.

We can copy from the previous article the implementation of the `FindRepositoriesByUserIdPort` using the cache to retrieve information:

```java
class FindRepositoriesByUserIdCache implements FindRepositoriesByUserIdPort {

  private final Map<UserId, List<Repository>> cache = new HashMap<>();

  public FindRepositoriesByUserIdCache() {
    cache.put(
          new UserId(42L),
          List.of(
              new Repository(
                  "rockthejvm.github.io",
                  Visibility.PUBLIC,
                  URI.create("https://github.com/rockthejvm/rockthejvm.github.io"))));
  }

  @Override
  public List<Repository> findRepositories(UserId userId) throws InterruptedException {
    // Simulates access to a distributed cache (Redis?)
    delay(Duration.ofMillis(100L));
    final List<Repository> repositories = cache.get(userId);
    if (repositories == null) {
      LOGGER.info("No cached repositories found for user with id '{}'", userId);
      throw new NoSuchElementException(
          "No cached repositories found for user with id '%s'".formatted(userId));
    }
    return repositories;
  }

  public void addToCache(UserId userId, List<Repository> repositories)
      throws InterruptedException {
    // Simulates access to a distributed cache (Redis?)
    delay(Duration.ofMillis(100L));
    cache.put(userId, repositories);
  }
}
```

As you might remember, the above implementation throws a `NoSuchElementException` if the user is not found in the cache to show that the joiner discard the subtask that fails if any following subtask succeeds. We can now implement the `FindRepositoriesByUserIdPort` to fetch the repositories both from the cache and from GitHub:

```java
class GitHubCachedRepository implements FindRepositoriesByUserIdPort {

  private final FindRepositoriesByUserIdPort repository;
  private final FindRepositoriesByUserIdCache cache;

  GitHubCachedRepository(
      FindRepositoriesByUserIdPort repository, FindRepositoriesByUserIdCache cache) {
    this.repository = repository;
    this.cache = cache;
  }

  @Override
  public List<Repository> findRepositories(UserId userId)
      throws InterruptedException, FailedException {
    try (var scope =
        StructuredTaskScope.open(Joiner.<List<Repository>>anySuccessfulResultOrThrow())) {
      scope.fork(() -> cache.findRepositories(userId));
      scope.fork(
          () -> {
            final List<Repository> repositories = repository.findRepositories(userId);
            cache.addToCache(userId, repositories);
            return repositories;
          });
      return scope.join();
    }
  }
}
```

As the best practice says, if we retrieve the repositories directly from GitHub, we also add them to the cache for future requests. Let's play with the new service. First, we'll use it to fetch a user that is not in the cache, so it will be fetched from GitHub.

```java
void main() throws InterruptedException {
  final GitHubRepository gitHubRepository = new GitHubRepository();
  final FindRepositoriesByUserIdCache cache = new FindRepositoriesByUserIdCache();
  final FindRepositoriesByUserIdPort gitHubCachedRepository =
      new GitHubCachedRepository(gitHubRepository, cache);
  final List<Repository> repositories = gitHubCachedRepository.findRepositories(new UserId(1L));
  LOGGER.info("GitHub user's repositories: {}", repositories);
}
```

We expect the cache to throw an exception since the repositories of the user with `UserId(1L)` are not cached and the repository to complete the execution successfully. As we said, the `AnySuccessful<T>` joiner waits for the first successful task. The output of the execution is, in fact, the following:

```
11:53:52.760 [virtual-27] INFO  in.rcard.sc.Main - Finding repositories for user with id 'UserId[value=1]'
11:53:52.864 [virtual-25] INFO  in.rcard.sc.Main - No cached repositories found for user with id 'UserId[value=1]'
11:53:53.773 [virtual-27] INFO  in.rcard.sc.Main - Repositories found for user 'UserId[value=1]'
11:53:53.877 [main] INFO  in.rcard.sc.Main - GitHub user's repositories: [Repository[name=raise4s, visibility=PUBLIC, uri=https://github.com/rcardin/raise4s], Repository[name=sus4s, visibility=PUBLIC, uri=https://github.com/rcardin/sus4s]]
```

As we can see, the cache task throws an exception, and the repository task completes successfully. The computation stops, and the result is the one we expect.

The other left cases behaviors are the same as in the previous versions, and we're not going to cover them in this article. The only difference with the previous versions is that it's not possible to give a remapping function to transform the exception thrown by the `join()` method. We saw the same bahaviour with the previous joiners we saw.

Until now we saw the new versions of the old structured concurrency policies, but in the JDK 25 there are also new joiners that implement new concurrency policies. Let's see them in action.

## New Structured Concurrency Policies (aka Joiners) in JDK 25

There will be new joiners in JDK 25 that implement new concurrency policies, which are not just variations of the old ones. These joiners provide more flexibility and power to structured concurrency.

The first one is the one we can retrieve using the `Joiner.awaitAll()` method. This joiner waits for all subtasks to complete, regardless of success or failure. It does not throw an exception if any subtask fails, and it always returns a simple `null`. Basically, we can use it when we are no interested in the results of the subtasks, or when our subtasks perform some side effects that we want to wait for, but we don't care about their results.

Let's built an example that uses this joiner. Let's say we want to preload the cache for some GitHub users before starting the application. First, we need to create a port to retrieve more than one user at a time:

```java
interface FindRepositoriesByUserIdListPort {
  Map<UserId, List<Repository>> findRepositories(List<UserId> userIds)
      throws InterruptedException;
}
```

We return a map of `UserId` to a list of `Repository` for convenience. We want the implementation to fetch the repositories for a list of users concurrently, and we want to wait for all subtasks to complete, regardless of success or failure. We can implement the port as follows:

```java
class GitHubRepository
      implements FindUserByIdPort, FindRepositoriesByUserIdPort, FindRepositoriesByUserIdListPort {

  // Omissis...

  @Override
  public Map<UserId, List<Repository>> findRepositories(List<UserId> userIds)
      throws InterruptedException {
    var repositoriesByUserId = new HashMap<UserId, List<Repository>>();
    try (var scope = StructuredTaskScope.open(Joiner.awaitAll())) {
      userIds.forEach(
          userId -> {
            scope.fork(
                () -> {
                  if (userId.equals(new UserId(42))) {
                    throw new RuntimeException(
                        "Network error while finding repositories for user '%s'"
                            .formatted(userId));
                  }
                  final List<Repository> repositories = findRepositories(userId);
                  repositoriesByUserId.put(userId, repositories);
                  return repositories;
                });
          });
      scope.join();
    }
    return repositoriesByUserId;
  }
}
```

We throw an exception for the user with `UserId(42)` to simulate a failure in one of the subtasks. Let's use the new port to preload the cache for some users. We change the `FindRepositoriesByUserIdCache` as follows:

```java
class FindRepositoriesByUserIdCache implements FindRepositoriesByUserIdPort {

  private final Map<UserId, List<Repository>> cache;
  public FindRepositoriesByUserIdCache(FindRepositoriesByUserIdListPort findRepositories) throws InterruptedException {
    this.cache = findRepositories.findRepositories(List.of(new UserId(1L), new UserId(2L), new UserId(42L)));
  }

  @Override
  public List<Repository> findRepositories(UserId userId) throws InterruptedException {
    // Simulates access to a distributed cache (Redis?)
    delay(Duration.ofMillis(100L));
    final List<Repository> repositories = cache.get(userId);
    if (repositories == null) {
      LOGGER.info("No cached repositories found for user with id '{}'", userId);
      throw new NoSuchElementException(
          "No cached repositories found for user with id '%s'".formatted(userId));
    }
    return repositories;
  }

  public void addToCache(UserId userId, List<Repository> repositories)
      throws InterruptedException {
    // Simulates access to a distributed cache (Redis?)
    delay(Duration.ofMillis(100L));
    cache.put(userId, repositories);
  }
}
```

As you can see, we changed the constructor to preload the cache with the repositories of the user with 1, 2, and 42. Let's use the new port to preload the cache and ask for the `UserId(42)` in the `main` method:

```java
void main() throws InterruptedException {
  final GitHubRepository gitHubRepository = new GitHubRepository();
  final FindRepositoriesByUserIdCache cache = new FindRepositoriesByUserIdCache(gitHubRepository);

  final List<Repository> repositories = cache.findRepositories(new UserId(42L));

  LOGGER.info("GitHub user's repositories: {}", repositories);
}
```

When we run the `main` method, we should see an output similar to the following:

```
21:03:20.708 [virtual-25] INFO  in.rcard.sc.Main - Finding repositories for user with id 'UserId[value=1]'
21:03:20.708 [virtual-27] INFO  in.rcard.sc.Main - Finding repositories for user with id 'UserId[value=2]'
21:03:21.718 [virtual-27] INFO  in.rcard.sc.Main - Repositories found for user 'UserId[value=2]'
21:03:21.718 [virtual-25] INFO  in.rcard.sc.Main - Repositories found for user 'UserId[value=1]'
21:03:21.825 [main] INFO  in.rcard.sc.Main - No cached repositories found for user with id 'UserId[value=42]'
Exception in thread "main" java.util.NoSuchElementException: No cached repositories found for user with id 'UserId[value=42]'
	at in.rcard.sc.Main$FindRepositoriesByUserIdCache.findRepositories(Main.java:173)
	at in.rcard.sc.Main.main(Main.java:219)
```

As expected, even if the subtask that fetches the repositories for the user with `UserId(42L)` fails, the other subtasks complete successfully. In fact, the output shows that the repositories for the users with `UserId(1L)` and `UserId(2L)` are found. So, the `scope.join()` method did not throw an exception, and waited for the end of all the three subtasks. The last exception comes from the implementation of the `cache.findRepositories(new UserId(42L))`, which is not related to the `awaitAll()` joiner.

The last joiner we see is the `Joiner.allUntil` joiner. Probably, it's the most powerful joiner introduced in JDK 25. It allows us to define a custom joiner that collects results from all subtasks until a certain condition is met. This joiner can be used to implement complex concurrency patterns. Let's start from the definition of the joiner:

```java
// JDK 25 Code Snippet
static final class AllSubtasks<T> implements Joiner<T, Stream<Subtask<T>>> {

  private final Predicate<Subtask<? extends T>> isDone;

  AllSubtasks(Predicate<Subtask<? extends T>> isDone) {
    this.isDone = Objects.requireNonNull(isDone);
  }

  // Omissis...
}
```

The joiner returns a stream of the forked subtasks, instead of a single result. Plus, the joiner takes a `Predicate<Subtask<? extends T>>` as a parameter, which is used to determine when to stop collecting results from the subtasks. In detail, when the predicate evaluates to `true`, the joiner stops collecting results and cancels any remaining subtasks. So, the returned subtasks can be in any state, including `SUCCESS`, `FAILED` for those that thrown an exception during the execution, and `UNAVAILABLE`for those who were cancelled.

As usual, we need an example to understand well how to use this joiner. Let's say we want to fetch the README file from multiple GitHub repositories concurrently, but we want to stop fetching as soon as we find a repository that has a README file. First, we need to create a port to fetch the files' names from a repository:

```java
interface FindAllRepositoryFilesPort {
  List<String> findAllFiles(Repository repository);
}
```

We can implement this port adding it to the `GitHubRepository` class as follows:

```java
class GitHubRepository
    implements FindUserByIdPort,
        FindRepositoriesByUserIdPort,
        FindRepositoriesByUserIdListPort,
        FindAllRepositoryFilesPort {
  // Omissis...

  @Override
  public List<String> findAllFiles(Repository repository) throws InterruptedException {
    LOGGER.info("Finding files for repository '{}'", repository.name);
    switch (repository.name) {
      case "raise4s" -> {
        delay(Duration.ofMillis(500L));
        return List.of("README.md", "src/main/scala/in/rcard/raise4s/Main.scala");
      }
      case "sus4s" -> {
        delay(Duration.ofMillis(100L));
        return List.of("src/main/scala/in/rcard/sus4s/Main.scala");
      }
      case "yaes" -> {
        delay(Duration.ofMillis(700L));
        return List.of("src/test/scala/in/rcard/yaes/MainTest.scala");
      }
      default -> {
        delay(Duration.ofMillis(250L));
        throw new RuntimeException("Unknown repository '%s'".formatted(repository.name));
      }
    }
  }
}
```

As we can see, only the `raise4s` repository has a `README.md` file. We added some delay for each repository to simulate the time it takes to fetch the files. Now, we can implement the use case to find the README file from multiple repositories. First, we need to add a data structure to hold the repository and its files:

```java
record RepoStructure(Repository repository, List<String> files) {}
```

Now, we can use it to implement the use case:

```java
interface FirstRepositoryByFileNameUseCase {
  Optional<Repository> firstRepositoryByFileName(
      List<Repository> repositories, String fileNameToMatch) throws InterruptedException;
}

class FirstRepositoryByFileNameService implements FirstRepositoryByFileNameUseCase {
  private final FindAllRepositoryFilesPort findAllFilesPort;
  FirstRepositoryByFileNameService(FindAllRepositoryFilesPort findAllFilesPort) {
    this.findAllFilesPort = findAllFilesPort;
  }
  @Override
  public Optional<Repository> firstRepositoryByFileName(
      List<Repository> repositories, String fileNameToMatch) throws InterruptedException {

    class CancelIfFound implements Predicate<Subtask<? extends RepoStructure>> {
      @Override
      public boolean test(Subtask<? extends RepoStructure> subtask) {
        return subtask.state() == Subtask.State.SUCCESS
            && subtask.get().files().contains(fileNameToMatch);
      }
    }

    var cancelIfFound = new CancelIfFound();

    try (var scope = StructuredTaskScope.open(Joiner.<RepoStructure>allUntil(cancelIfFound))) {
      repositories.forEach(
          repository ->
              scope.fork(
                  () -> {
                    final List<String> files = findAllFilesPort.findAllFiles(repository);
                    LOGGER.info(
                          "Found {} files for repository '{}'", files.size(), repository.name);†¬
                    return new RepoStructure(repository, files);
                  }));
      return scope
          .join()
          .filter(subtask -> subtask.state() == Subtask.State.SUCCESS)
          .findFirst()
          .map(subtask -> subtask.get().repository());
    }
  }
}
```

There are a few things to notice in the above implementation. We implemented a custom `Predicate<Subtask<? extends RepoStructure>>` that checks if the subtask has completed successfully and if the files returned by the subtask contain the file we are looking for. The class `CancelIfFound` will be used as our stopping condition for the joiner. (By the way, do you know that you can define classes inside methods in Java?).

We then use the `Joiner.allUntil(cancelIfFound)` to create a joiner that collects results from all subtasks until the predicate evaluates to `true`. Finally, we return the first repository that has the file we are looking for, if any.

Let's wire everything together in the `main` method:

```java
void main() throws InterruptedException {
  final FirstRepositoryByFileNameUseCase useCase =
      new FirstRepositoryByFileNameService(new GitHubRepository());
  final Optional<Repository> maybeRepoWithReadme =
      useCase.firstRepositoryByFileName(
          List.of(
              new Repository(
                  "raise4s", Visibility.PUBLIC, URI.create("https://github.com/rcardin/raise4s")),
              new Repository(
                  "sus4s", Visibility.PUBLIC, URI.create("https://github.com/rcardin/sus4s")),
              new Repository(
                  "yaes", Visibility.PUBLIC, URI.create("https://github.com/rcardin/yaes")),
              new Repository(
                  "kafkaesque",
                  Visibility.PUBLIC,
                  URI.create("https://github.com/rcardin/kafkaesque"))),
          "README.md");
  LOGGER.info(
      "First repository with 'README.md': {}",
      maybeRepoWithReadme.map(Repository::name).orElse("Not found"));
}
```

We want to find the first repository that has a `README.md` file. If you remember how we configured the delays, a coroutine will throw an exception for the repository `kafkaesque`, and another one will return the files for the `sus4s` repository, which does not contain a `README.md` file. Then, we have the coroutine that will return the files for the `raise4s` repository, which contains the file we are looking for. The last coroutine will never finish, as the joiner will cancel it as soon as it finds the first repository with the `README.md` file.

When we run the `main` method, we should see the following output:

```
21:48:48.193 [virtual-30] INFO  in.rcard.sc.Main - Finding files for repository 'yaes'
21:48:48.193 [virtual-25] INFO  in.rcard.sc.Main - Finding files for repository 'raise4s'
21:48:48.193 [virtual-32] INFO  in.rcard.sc.Main - Finding files for repository 'kafkaesque'
21:48:48.193 [virtual-27] INFO  in.rcard.sc.Main - Finding files for repository 'sus4s'
21:48:48.305 [virtual-27] INFO  in.rcard.sc.Main - Found 1 files for repository 'sus4s'
21:48:48.704 [virtual-25] INFO  in.rcard.sc.Main - Found 2 files for repository 'raise4s'
21:48:48.708 [main] INFO  in.rcard.sc.Main - First repository with 'README.md': raise4s
```


The logs show exactly what we expected: the coroutine that fetches the files for the `sus4s` repository completes first, but it does not contain the `README.md` file, so it continues to fetch the files for the `raise4s` repository, which contains the file we are looking for. The coroutine that fetches the files for the `kafkaesque` repository thrown an exception, which is ignored. The coroutine for the `yaes` repository never completed since it was cancelled by the runtime.

There no any other predefined joiners in JDK 25, but you can create your own joiners by implementing the `Joiner<T, R>` interface. This allows you to define custom concurrency policies that suit your specific needs. Let's see how in the next section.

## Custom Joiners: Implementing Your Own Concurrency Policies

In addition to the built-in joiners, you can create your own joiners to implement custom concurrency policies. This can be useful if you have specific requirements that are not met by the default joiners. As we saw in the previous article, the JDK does not provide a structured concurrency policy implementing the `race` pattern, where the first subtask that completes, successfully or not, returns its result, while the other subtasks are cancelled. We can implement this policy by creating a custom joiner.

The `Joiner` interface is a functional interface that defines a single method purely abstract method:

```java
// JDK 25 Code Snippet
@FunctionalInterface
public interface Joiner<T, R> {
    R result() throws Throwable;
}
```

The `Joiner` interface is generic also on `T` other than `R`. The `T` type variable represents the type of the result of the subtasks, while the `R` type variable represents the type of the final result of the scope.

As you might guess, the `StructuredTaskScope.join()` internally invokes the the `result()` method of the `Joiner` instance to retrieve the final result of the scope.

```java
// JDK 25 Code Snippet
@Override
public R join() throws InterruptedException {
    // A lot of code here...
    try {
        return joiner.result();
    } catch (Throwable e) {
        throw new FailedException(e);
    }
}
```

We can configure two aspects of the execution of a joiner, what happens when a subtask is forked and what happens when a subtask completes. For doing this, we can override the `onFork()` and `onComplete()` methods of the `Joiner` interface:

```java
// JDK 25 Code Snippet
default boolean onFork(Subtask<? extends T> subtask) {
    if (subtask.state() != Subtask.State.UNAVAILABLE) {
        throw new IllegalArgumentException("Subtask not in UNAVAILABLE state");
    }
    return false;
}

default boolean onComplete(Subtask<? extends T> subtask) {
    if (subtask.state() == Subtask.State.UNAVAILABLE) {
        throw new IllegalArgumentException("Subtask has not completed");
    }
    return false;
}
```

As the names suggest, the `onFork()` method is called when a subtask is forked, and the `onComplete()` method is called when a subtask completes. Both methods return a boolean value that indicates whether the outer scope should be cancelled or not.

In our case, we want to implement a joiner that collects the results of all subtasks until one of them completes successfully or fails. If a subtask completes successfully, we return its result; if it fails, we cancel the remaining subtasks and return the result of the first successful subtask. Let's call it `FirstCompleted`. We also need some variables to hold the result of the first completed subtask:

```java
class FirstCompleted<T> implements Joiner<T, T> {
  private T firstResult;
  private Throwable firstException;

  // Omissis...
}
```

We don't need to do anything in the `onFork()` method, so we can leave it as the default implementation. In the `onComplete()` method, we check the state of the subtask and update our variables accordingly. Remember though that the `onComplete()` must be thread safe, as it can be called concurrently by multiple threads. Then, the access to the `firstResult` and `firstException` variables must be synchronized:

```java
@Override
public boolean onComplete(Subtask<? extends T> subtask) {
  return switch (subtask.state()) {
    case SUCCESS -> {
      synchronized (this) {
        if (firstResult == null) {
          firstResult = subtask.get();
        }
        yield true;
      }
    }
    case FAILED -> {
      synchronized (this) {
        if (firstException == null) {
          firstException = subtask.exception();
        }
        yield true;
      }
    }
    case UNAVAILABLE -> Joiner.super.onComplete(subtask);
  };
}
```

In the previous article we used a reentrant lock to synchronize the access to the shared variables, since in JDK 23 the execution of a synchronized block pins the carrier thread to the virtual thread that is executing the block. In JDK 25, this is no longer the case, so we can use a simple synchronized block to protect the access to the shared variables (see [The Ultimate Guide to Java Virtual Threads - Pinned Virtual Threads](https://rockthejvm.com/articles/the-ultimate-guide-to-java-virtual-threads#pinned-virtual-threads) for further details).

As you can see, in both `SUCCESS` and `FAILED` cases, we are returning `true`, which means that the outer scope should be cancelled. This is because we want to stop the execution of the remaining subtasks as soon as one of them completes successfully or fails. In previous versions of the JDK we must invoke the `StructuredTaskScope.shutdown()` method explicitly to cancel the remaining subtasks.

Finally, we implement the `result()` method to return the first result or throw an exception if no subtask completed successfully:

```java
@Override
public T result() throws Throwable {
  if (firstException != null) {
    throw firstException;
  }
  return firstResult;
}
```

Nothing special here, we just check if the `firstException` is not null and throw it if it is. Otherwise, we return the `firstResult`.

You might have noticed that all the checks on thread ownership are gone. In the JDK 25 the Java architects made a big refactoring to better separate the concerns of the structured concurrency API. Now, the `StructuredTaskScope` is responsible for managing the lifecycle of the subtasks, while the `Joiner` is responsible for defining the concurrency policy. This means that we don't need to check if the subtask is owned by the current thread anymore, as the `StructuredTaskScope` takes care of that.

Be careful, though: the `onComplete` method is not called if the subtask completes after the outer scope has been cancelled.

So, the complete implementation of the `FirstCompleted` joiner looks like this:

```java
class FirstCompleted<T> implements Joiner<T, T> {
  private T firstResult;
  private Throwable firstException;

  @Override
  public boolean onComplete(Subtask<? extends T> subtask) {
    return switch (subtask.state()) {
      case SUCCESS -> {
        synchronized (this) {
          if (firstResult == null) {
            firstResult = subtask.get();
          }
          yield true;
        }
      }
      case FAILED -> {
        synchronized (this) {
          if (firstException == null) {
            firstException = subtask.exception();
          }
          yield true;
        }
      }
      case UNAVAILABLE -> Joiner.super.onComplete(subtask);
    };
  }

  @Override
  public T result() throws Throwable {
    if (firstException != null) {
      throw firstException;
    }
    return firstResult;
  }
}
```

If you compare this implementation with the one we saw in the previous article, you can see that it is much simpler and cleaner. As we said, it's a consequence of the refactoring made in JDK 25, which separates the concerns of the structured concurrency API.

As in the previous article, we'll use the new concurrency policy to implement a use case that fetches the repositories of a GitHub user within a given timeout. If the repositories are not found within the timeout, we'll fail with an exception. The `FirstCompleted` joiner will ensure the subtasks that don't win the race are cancelled, and we only return the result of the first subtask that completes successfully or fails.

Here is the code:

```java
class FindRepositoriesByUserIdWithTimeout {
  final FindRepositoriesByUserIdPort delegate;

  FindRepositoriesByUserIdWithTimeout(FindRepositoriesByUserIdPort delegate) {
    this.delegate = delegate;
  }

  List<Repository> findRepositories(UserId userId, Duration timeout) throws InterruptedException {
    try (var scope = StructuredTaskScope.open(new FirstCompleted<List<Repository>>())) {
      scope.fork(() -> delegate.findRepositories(userId));
      scope.fork(
          () -> {
            delay(timeout);
            throw new TimeoutException("Timeout of %s reached".formatted(timeout));
          });
      return scope.join();
    }
  }
}
```

If you remember, the base implementation of the `FindRepositoriesByUserIdPort` waits 1 second before returning the repositories, so simulate the timeout use case passing a timeout of 500 milliseconds:

```java
void main() throws InterruptedException {

  final GitHubRepository gitHubRepository = new GitHubRepository();
  final FindRepositoriesByUserIdWithTimeout findRepositoriesWithTimeout =
      new FindRepositoriesByUserIdWithTimeout(gitHubRepository);

  final List<Repository> repositories =
      findRepositoriesWithTimeout.findRepositories(new UserId(1L), Duration.ofMillis(500L));

  LOGGER.info("GitHub user's repositories: {}", repositories);
}
```

The execution of the `main` method should produce the following output:

```
09:21:48.571 [virtual-25] INFO  in.rcard.sc.Main - Finding repositories for user with id 'UserId[value=1]'
Exception in thread "main" java.util.concurrent.StructuredTaskScope$FailedException: java.util.concurrent.TimeoutException: Timeout of PT0.5S reached
	at java.base/java.util.concurrent.StructuredTaskScopeImpl.join(StructuredTaskScopeImpl.java:258)
	at in.rcard.sc.Main$FindRepositoriesByUserIdWithTimeout.findRepositories(Main.java:359)
	at in.rcard.sc.Main.main(Main.java:371)
Caused by: java.util.concurrent.TimeoutException: Timeout of PT0.5S reached
	at in.rcard.sc.Main$FindRepositoriesByUserIdWithTimeout.lambda$findRepositories$1(Main.java:357)
	at java.base/java.util.concurrent.StructuredTaskScopeImpl$SubtaskImpl.run(StructuredTaskScopeImpl.java:325)
	at java.base/java.lang.VirtualThread.run(VirtualThread.java:456)
```

The execution hit the timeout, and the subtask retrieving the repositories was cancelled. In fact, it didn't write the second log message.

Whereas, if we increase the timeout to 1.5 seconds, the computation retrieves the repositories successfully:

```
09:26:18.321 [virtual-25] INFO  in.rcard.sc.Main - Finding repositories for user with id 'UserId[value=1]'
09:26:19.335 [virtual-25] INFO  in.rcard.sc.Main - Repositories found for user 'UserId[value=1]'
09:26:19.338 [main] INFO  in.rcard.sc.Main - GitHub user's repositories: [Repository[name=raise4s, visibility=PUBLIC, uri=https://github.com/rcardin/raise4s], Repository[name=sus4s, visibility=PUBLIC, uri=https://github.com/rcardin/sus4s]]
```

As we did in the previous article, we could use the `FirstCompleted` joiner to implement the `race` structured concurrency primitive. However, it does not differ from that we did previously, so we will omit that example here.

As we seen, we created a customer joiner and we used it to implement a timeout policy for a use case. If we need to set up a timeout the JDK 25 lets us to configure the structured task scope with a timeout, and other configuration options. Let's see how to do that in the next section.

## Configuring Structured Task Scopes in JDK 25

As we saw, when creating a `StructuredTaskScope`, we can pass a `Joiner` instance to the `open()` method. This allows us to define the concurrency policy for the scope. However, in JDK 25, the `open()` has another overload that allows us to configure the scope with additional options:

```java
// JDK 25 Code Snippet
static <T, R> StructuredTaskScope<T, R> open(Joiner<? super T, ? extends R> joiner,
    Function<Configuration, Configuration> configFunction)
```

The type implementing the configuration is the `Configuration` interface:

```java
// JDK 25 Code Snippet
sealed interface Configuration permits StructuredTaskScopeImpl.ConfigImpl {
  Configuration withThreadFactory(ThreadFactory threadFactory);
  Configuration withName(String name);
  Configuration withTimeout(Duration timeout);
}
```

As we can see, the overloaded `open()` method takes a `Function<Configuration, Configuration>` as a second parameter. The input parameter of the function represents the default configuration of the scope that we can modify using the methods of the `Configuration` interface. We can configure the name of the threads created by the scope for debugging purposes, the thread factory to use if we want to limit the parallelism of the scope, and the maximum execution timeout.

To see the configuration in action, let's implement the previous version of the `FindRepositoriesByUserIdWithTimeout` use case using the new configuration options:

```java
class FindRepositoriesByUserIdWithConfigTimeout {

  final FindRepositoriesByUserIdPort delegate;

  FindRepositoriesByUserIdWithConfigTimeout(FindRepositoriesByUserIdPort delegate) {
    this.delegate = delegate;
  }

  List<Repository> findRepositories(UserId userId, Duration timeout) throws InterruptedException {
    try (var scope =
        StructuredTaskScope.open(
            Joiner.<List<Repository>>anySuccessfulResultOrThrow(),
            config -> config.withName("timed").withTimeout(timeout))) {
      scope.fork(() -> delegate.findRepositories(userId));
      return scope.join();
    }
  }
}
```

Clearly, using structured concurrency to timeout a single task is an overkill, but it shows how to use the new configuration options. We set also the name of the scope to "timed", and we see that the `Configuration` type works like a builder, allowing us to chain the configuration methods. Every time we call a method on the `Configuration` instance, it returns a new instance with the updated configuration. In fact, the implementation of the `Configuration` interface under the hood is the following:

```java
// JDK 25 Code Snippet
record ConfigImpl(
    ThreadFactory threadFactory,
    String name,
    Duration timeout) implements Configuration {

  static Configuration defaultConfig() {
      return new ConfigImpl(Thread.ofVirtual().factory(), null, null);
  }
  @Override
  public Configuration withThreadFactory(ThreadFactory threadFactory) {
      return new ConfigImpl(Objects.requireNonNull(threadFactory), name, timeout);
  }
  @Override
  public Configuration withName(String name) {
      return new ConfigImpl(threadFactory, Objects.requireNonNull(name), timeout);
  }
  @Override
  public Configuration withTimeout(Duration timeout) {
      return new ConfigImpl(threadFactory, name, Objects.requireNonNull(timeout));
  }
}
```

If we try to use our new `FindRepositoriesByUserIdWithConfigTimeout` class in the `main` method with a timeout equal to 500 milliseconds, we can see that it works as expected:

```java
14:34:16.960 [virtual-26] INFO  in.rcard.sc.Main - Finding repositories for user with id 'UserId[value=1]'
Exception in thread "main" java.util.concurrent.StructuredTaskScope$TimeoutException
	at java.base/java.util.concurrent.StructuredTaskScopeImpl.join(StructuredTaskScopeImpl.java:247)
	at in.rcard.sc.Main$FindRepositoriesByUserIdWithConfigTimeout.findRepositories(Main.java:378)
	at in.rcard.sc.Main.main(Main.java:390)
```

Unfortunately, we can't see the name of the scope in the logs.

## Conclusion

JDK 25's structured concurrency represents a significant evolution from the previous versions. The new `Joiner` API provides unprecedented flexibility while maintaining the simplicity that makes structured concurrency so appealing. The static factory methods and enhanced configuration options make the API more intuitive and powerful.

The journey from unstructured concurrency with `ExecutorService` to the elegant structured concurrency of JDK 25 shows how Java continues to evolve to meet the needs of modern concurrent programming. Virtual threads provide the scalability, and structured concurrency provides the safety and clarity we need to build robust, maintainable applications.

As structured concurrency moves towards finalization in future Java releases, now is the perfect time to start experimenting with these new APIs and integrating them into your applications. The combination of virtual threads and structured concurrency represents the future of concurrent programming in Java, offering both performance and maintainability that traditional approaches simply cannot match.

The concepts we've explored here - from basic scope creation to custom joiners and resilient service patterns - provide a solid foundation for building the next generation of concurrent Java applications. As you adopt these patterns, you'll find that concurrent programming becomes not just more performant, but also more enjoyable and less error-prone.
